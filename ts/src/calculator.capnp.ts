/* tslint:disable */

/**
 * This file has been automatically generated by the [capnpc-ts utility](https://github.com/jdiaz5513/capnp-ts).
 */

import * as capnp from "capnp-ts";
import { ObjectSize as __O, Struct as __S, Interface as __I } from 'capnp-ts';
export const _capnpFileId = "85150b117366d14b";
export class Calculator_Expression_Call extends __S {
    static readonly _capnp = { displayName: "call", id: "d99522a3d3878d66", size: new __O(16, 2) };
    static _Params: capnp.ListCtor<Calculator_Expression>;
    getFunction(): Calculator_Function$Client { return new Calculator_Function$Client(__S.getInterfaceClientOrNullAt(0, this)); }
    setFunction(value: Calculator_Function$Client): void { __S.setInterfacePointer(this.segment.message.addCap(value.client), __S.getPointer(0, this)); }
    adoptParams(value: capnp.Orphan<capnp.List<Calculator_Expression>>): void { __S.adopt(value, __S.getPointer(1, this)); }
    disownParams(): capnp.Orphan<capnp.List<Calculator_Expression>> { return __S.disown(this.getParams()); }
    getParams(): capnp.List<Calculator_Expression> { return __S.getList(1, Calculator_Expression_Call._Params, this); }
    hasParams(): boolean { return !__S.isNull(__S.getPointer(1, this)); }
    initParams(length: number): capnp.List<Calculator_Expression> { return __S.initList(1, Calculator_Expression_Call._Params, length, this); }
    setParams(value: capnp.List<Calculator_Expression>): void { __S.copyFrom(value, __S.getPointer(1, this)); }
    toString(): string { return "Calculator_Expression_Call_" + super.toString(); }
}
export enum Calculator_Expression_Which {
    LITERAL = 0,
    PREVIOUS_RESULT = 1,
    PARAMETER = 2,
    CALL = 3
}
export class Calculator_Expression extends __S {
    static readonly LITERAL = Calculator_Expression_Which.LITERAL;
    static readonly PREVIOUS_RESULT = Calculator_Expression_Which.PREVIOUS_RESULT;
    static readonly PARAMETER = Calculator_Expression_Which.PARAMETER;
    static readonly CALL = Calculator_Expression_Which.CALL;
    static readonly _capnp = { displayName: "Expression", id: "d438d7caf5548d15", size: new __O(16, 2) };
    getLiteral(): number {
        __S.testWhich("literal", __S.getUint16(8, this), 0, this);
        return __S.getFloat64(0, this);
    }
    isLiteral(): boolean { return __S.getUint16(8, this) === 0; }
    setLiteral(value: number): void {
        __S.setUint16(8, 0, this);
        __S.setFloat64(0, value, this);
    }
    getPreviousResult(): Calculator_Value$Client {
        __S.testWhich("previousResult", __S.getUint16(8, this), 1, this);
        return new Calculator_Value$Client(__S.getInterfaceClientOrNullAt(0, this));
    }
    isPreviousResult(): boolean { return __S.getUint16(8, this) === 1; }
    setPreviousResult(value: Calculator_Value$Client): void {
        __S.setUint16(8, 1, this);
        __S.setInterfacePointer(this.segment.message.addCap(value.client), __S.getPointer(0, this));
    }
    getParameter(): number {
        __S.testWhich("parameter", __S.getUint16(8, this), 2, this);
        return __S.getUint32(0, this);
    }
    isParameter(): boolean { return __S.getUint16(8, this) === 2; }
    setParameter(value: number): void {
        __S.setUint16(8, 2, this);
        __S.setUint32(0, value, this);
    }
    getCall(): Calculator_Expression_Call {
        __S.testWhich("call", __S.getUint16(8, this), 3, this);
        return __S.getAs(Calculator_Expression_Call, this);
    }
    initCall(): Calculator_Expression_Call {
        __S.setUint16(8, 3, this);
        return __S.getAs(Calculator_Expression_Call, this);
    }
    isCall(): boolean { return __S.getUint16(8, this) === 3; }
    setCall(): void { __S.setUint16(8, 3, this); }
    toString(): string { return "Calculator_Expression_" + super.toString(); }
    which(): Calculator_Expression_Which { return __S.getUint16(8, this); }
}
export class Calculator_Value_Read$Params extends __S {
    static readonly _capnp = { displayName: "read$Params", id: "d3532574d58db558", size: new __O(0, 0) };
    toString(): string { return "Calculator_Value_Read$Params_" + super.toString(); }
}
export class Calculator_Value_Read$Results extends __S {
    static readonly _capnp = { displayName: "read$Results", id: "e6be6723122ae822", size: new __O(8, 0) };
    getValue(): number { return __S.getFloat64(0, this); }
    setValue(value: number): void { __S.setFloat64(0, value, this); }
    toString(): string { return "Calculator_Value_Read$Results_" + super.toString(); }
}
export class Calculator_Value_Read$Results$Promise {
    pipeline: capnp.Pipeline<any, any, Calculator_Value_Read$Results>;
    constructor(pipeline: capnp.Pipeline<any, any, Calculator_Value_Read$Results>) {
        this.pipeline = pipeline;
    }
    async promise(): Promise<Calculator_Value_Read$Results> {
        return await this.pipeline.struct();
    }
}
export class Calculator_Value$Client {
    client: capnp.Client;
    static readonly interfaceId: capnp.Uint64 = capnp.Uint64.fromHexString("c3e69d34d3ee48d2");
    constructor(client: capnp.Client) {
        this.client = client;
    }
    static readonly methods: [capnp.Method<Calculator_Value_Read$Params, Calculator_Value_Read$Results>] = [
        {
            ParamsClass: Calculator_Value_Read$Params,
            ResultsClass: Calculator_Value_Read$Results,
            interfaceId: Calculator_Value$Client.interfaceId,
            methodId: 0,
            interfaceName: "calculator.capnp:Calculator.Value",
            methodName: "read"
        }
    ];
    read(paramsFunc?: (params: Calculator_Value_Read$Params) => void): Calculator_Value_Read$Results$Promise {
        const answer = this.client.call({
            method: Calculator_Value$Client.methods[0],
            paramsFunc: paramsFunc
        });
        const pipeline = new capnp.Pipeline(Calculator_Value_Read$Results, answer);
        return new Calculator_Value_Read$Results$Promise(pipeline);
    }
}
capnp.Registry.register(Calculator_Value$Client.interfaceId, Calculator_Value$Client);
export interface Calculator_Value$Server$Target {
    read(params: Calculator_Value_Read$Params, results: Calculator_Value_Read$Results): Promise<void>;
}
export class Calculator_Value$Server extends capnp.Server {
    readonly target: Calculator_Value$Server$Target;
    constructor(target: Calculator_Value$Server$Target) {
        super(target, [
            {
                ...Calculator_Value$Client.methods[0],
                impl: target.read
            }
        ]);
        this.target = target;
    }
    client(): Calculator_Value$Client { return new Calculator_Value$Client(this); }
}
export class Calculator_Value extends __I {
    static readonly Client = Calculator_Value$Client;
    static readonly Server = Calculator_Value$Server;
    static readonly _capnp = { displayName: "Value", id: "c3e69d34d3ee48d2", size: new __O(0, 0) };
    toString(): string { return "Calculator_Value_" + super.toString(); }
}
export class Calculator_Function_Call$Params extends __S {
    static readonly _capnp = { displayName: "call$Params", id: "b19160df70b87717", size: new __O(0, 1) };
    adoptParams(value: capnp.Orphan<capnp.List<number>>): void { __S.adopt(value, __S.getPointer(0, this)); }
    disownParams(): capnp.Orphan<capnp.List<number>> { return __S.disown(this.getParams()); }
    getParams(): capnp.List<number> { return __S.getList(0, capnp.Float64List, this); }
    hasParams(): boolean { return !__S.isNull(__S.getPointer(0, this)); }
    initParams(length: number): capnp.List<number> { return __S.initList(0, capnp.Float64List, length, this); }
    setParams(value: capnp.List<number>): void { __S.copyFrom(value, __S.getPointer(0, this)); }
    toString(): string { return "Calculator_Function_Call$Params_" + super.toString(); }
}
export class Calculator_Function_Call$Results extends __S {
    static readonly _capnp = { displayName: "call$Results", id: "c0e0abf76914dead", size: new __O(8, 0) };
    getValue(): number { return __S.getFloat64(0, this); }
    setValue(value: number): void { __S.setFloat64(0, value, this); }
    toString(): string { return "Calculator_Function_Call$Results_" + super.toString(); }
}
export class Calculator_Function_Call$Results$Promise {
    pipeline: capnp.Pipeline<any, any, Calculator_Function_Call$Results>;
    constructor(pipeline: capnp.Pipeline<any, any, Calculator_Function_Call$Results>) {
        this.pipeline = pipeline;
    }
    async promise(): Promise<Calculator_Function_Call$Results> {
        return await this.pipeline.struct();
    }
}
export class Calculator_Function$Client {
    client: capnp.Client;
    static readonly interfaceId: capnp.Uint64 = capnp.Uint64.fromHexString("ede83a3d96840394");
    constructor(client: capnp.Client) {
        this.client = client;
    }
    static readonly methods: [capnp.Method<Calculator_Function_Call$Params, Calculator_Function_Call$Results>] = [
        {
            ParamsClass: Calculator_Function_Call$Params,
            ResultsClass: Calculator_Function_Call$Results,
            interfaceId: Calculator_Function$Client.interfaceId,
            methodId: 0,
            interfaceName: "calculator.capnp:Calculator.Function",
            methodName: "call"
        }
    ];
    call(paramsFunc?: (params: Calculator_Function_Call$Params) => void): Calculator_Function_Call$Results$Promise {
        const answer = this.client.call({
            method: Calculator_Function$Client.methods[0],
            paramsFunc: paramsFunc
        });
        const pipeline = new capnp.Pipeline(Calculator_Function_Call$Results, answer);
        return new Calculator_Function_Call$Results$Promise(pipeline);
    }
}
capnp.Registry.register(Calculator_Function$Client.interfaceId, Calculator_Function$Client);
export interface Calculator_Function$Server$Target {
    call(params: Calculator_Function_Call$Params, results: Calculator_Function_Call$Results): Promise<void>;
}
export class Calculator_Function$Server extends capnp.Server {
    readonly target: Calculator_Function$Server$Target;
    constructor(target: Calculator_Function$Server$Target) {
        super(target, [
            {
                ...Calculator_Function$Client.methods[0],
                impl: target.call
            }
        ]);
        this.target = target;
    }
    client(): Calculator_Function$Client { return new Calculator_Function$Client(this); }
}
export class Calculator_Function extends __I {
    static readonly Client = Calculator_Function$Client;
    static readonly Server = Calculator_Function$Server;
    static readonly _capnp = { displayName: "Function", id: "ede83a3d96840394", size: new __O(0, 0) };
    toString(): string { return "Calculator_Function_" + super.toString(); }
}
export enum Calculator_Operator {
    ADD,
    SUBTRACT,
    MULTIPLY,
    DIVIDE
}
export class Calculator_Evaluate$Params extends __S {
    static readonly _capnp = { displayName: "evaluate$Params", id: "bb0eaae1557a36d4", size: new __O(0, 1) };
    adoptExpression(value: capnp.Orphan<Calculator_Expression>): void { __S.adopt(value, __S.getPointer(0, this)); }
    disownExpression(): capnp.Orphan<Calculator_Expression> { return __S.disown(this.getExpression()); }
    getExpression(): Calculator_Expression { return __S.getStruct(0, Calculator_Expression, this); }
    hasExpression(): boolean { return !__S.isNull(__S.getPointer(0, this)); }
    initExpression(): Calculator_Expression { return __S.initStructAt(0, Calculator_Expression, this); }
    setExpression(value: Calculator_Expression): void { __S.copyFrom(value, __S.getPointer(0, this)); }
    toString(): string { return "Calculator_Evaluate$Params_" + super.toString(); }
}
export class Calculator_Evaluate$Results extends __S {
    static readonly _capnp = { displayName: "evaluate$Results", id: "81b1a3f55887a611", size: new __O(0, 1) };
    getValue(): Calculator_Value$Client { return new Calculator_Value$Client(__S.getInterfaceClientOrNullAt(0, this)); }
    setValue(value: Calculator_Value$Client): void { __S.setInterfacePointer(this.segment.message.addCap(value.client), __S.getPointer(0, this)); }
    toString(): string { return "Calculator_Evaluate$Results_" + super.toString(); }
}
export class Calculator_Evaluate$Results$Promise {
    pipeline: capnp.Pipeline<any, any, Calculator_Evaluate$Results>;
    constructor(pipeline: capnp.Pipeline<any, any, Calculator_Evaluate$Results>) {
        this.pipeline = pipeline;
    }
    getValue(): Calculator_Value$Client {
        return new Calculator_Value$Client(this.pipeline.getPipeline(Calculator_Value, 0).client());
    }
    async promise(): Promise<Calculator_Evaluate$Results> {
        return await this.pipeline.struct();
    }
}
export class Calculator_DefFunction$Params extends __S {
    static readonly _capnp = { displayName: "defFunction$Params", id: "f287bcba4556dc89", size: new __O(8, 1) };
    getParamCount(): number { return __S.getInt32(0, this); }
    setParamCount(value: number): void { __S.setInt32(0, value, this); }
    adoptBody(value: capnp.Orphan<Calculator_Expression>): void { __S.adopt(value, __S.getPointer(0, this)); }
    disownBody(): capnp.Orphan<Calculator_Expression> { return __S.disown(this.getBody()); }
    getBody(): Calculator_Expression { return __S.getStruct(0, Calculator_Expression, this); }
    hasBody(): boolean { return !__S.isNull(__S.getPointer(0, this)); }
    initBody(): Calculator_Expression { return __S.initStructAt(0, Calculator_Expression, this); }
    setBody(value: Calculator_Expression): void { __S.copyFrom(value, __S.getPointer(0, this)); }
    toString(): string { return "Calculator_DefFunction$Params_" + super.toString(); }
}
export class Calculator_DefFunction$Results extends __S {
    static readonly _capnp = { displayName: "defFunction$Results", id: "8d24f465047cd6c8", size: new __O(0, 1) };
    getFunc(): Calculator_Function$Client { return new Calculator_Function$Client(__S.getInterfaceClientOrNullAt(0, this)); }
    setFunc(value: Calculator_Function$Client): void { __S.setInterfacePointer(this.segment.message.addCap(value.client), __S.getPointer(0, this)); }
    toString(): string { return "Calculator_DefFunction$Results_" + super.toString(); }
}
export class Calculator_DefFunction$Results$Promise {
    pipeline: capnp.Pipeline<any, any, Calculator_DefFunction$Results>;
    constructor(pipeline: capnp.Pipeline<any, any, Calculator_DefFunction$Results>) {
        this.pipeline = pipeline;
    }
    getFunc(): Calculator_Function$Client {
        return new Calculator_Function$Client(this.pipeline.getPipeline(Calculator_Function, 0).client());
    }
    async promise(): Promise<Calculator_DefFunction$Results> {
        return await this.pipeline.struct();
    }
}
export class Calculator_GetOperator$Params extends __S {
    static readonly _capnp = { displayName: "getOperator$Params", id: "8a8dceb4f4a3c530", size: new __O(8, 0) };
    getOp(): Calculator_Operator { return __S.getUint16(0, this); }
    setOp(value: Calculator_Operator): void { __S.setUint16(0, value, this); }
    toString(): string { return "Calculator_GetOperator$Params_" + super.toString(); }
}
export class Calculator_GetOperator$Results extends __S {
    static readonly _capnp = { displayName: "getOperator$Results", id: "d18fbb7763c08c20", size: new __O(0, 1) };
    getFunc(): Calculator_Function$Client { return new Calculator_Function$Client(__S.getInterfaceClientOrNullAt(0, this)); }
    setFunc(value: Calculator_Function$Client): void { __S.setInterfacePointer(this.segment.message.addCap(value.client), __S.getPointer(0, this)); }
    toString(): string { return "Calculator_GetOperator$Results_" + super.toString(); }
}
export class Calculator_GetOperator$Results$Promise {
    pipeline: capnp.Pipeline<any, any, Calculator_GetOperator$Results>;
    constructor(pipeline: capnp.Pipeline<any, any, Calculator_GetOperator$Results>) {
        this.pipeline = pipeline;
    }
    getFunc(): Calculator_Function$Client {
        return new Calculator_Function$Client(this.pipeline.getPipeline(Calculator_Function, 0).client());
    }
    async promise(): Promise<Calculator_GetOperator$Results> {
        return await this.pipeline.struct();
    }
}
export class Calculator$Client {
    client: capnp.Client;
    static readonly interfaceId: capnp.Uint64 = capnp.Uint64.fromHexString("97983392df35cc36");
    constructor(client: capnp.Client) {
        this.client = client;
    }
    static readonly methods: [capnp.Method<Calculator_Evaluate$Params, Calculator_Evaluate$Results>, capnp.Method<Calculator_DefFunction$Params, Calculator_DefFunction$Results>, capnp.Method<Calculator_GetOperator$Params, Calculator_GetOperator$Results>] = [
        {
            ParamsClass: Calculator_Evaluate$Params,
            ResultsClass: Calculator_Evaluate$Results,
            interfaceId: Calculator$Client.interfaceId,
            methodId: 0,
            interfaceName: "calculator.capnp:Calculator",
            methodName: "evaluate"
        },
        {
            ParamsClass: Calculator_DefFunction$Params,
            ResultsClass: Calculator_DefFunction$Results,
            interfaceId: Calculator$Client.interfaceId,
            methodId: 1,
            interfaceName: "calculator.capnp:Calculator",
            methodName: "defFunction"
        },
        {
            ParamsClass: Calculator_GetOperator$Params,
            ResultsClass: Calculator_GetOperator$Results,
            interfaceId: Calculator$Client.interfaceId,
            methodId: 2,
            interfaceName: "calculator.capnp:Calculator",
            methodName: "getOperator"
        }
    ];
    evaluate(paramsFunc?: (params: Calculator_Evaluate$Params) => void): Calculator_Evaluate$Results$Promise {
        const answer = this.client.call({
            method: Calculator$Client.methods[0],
            paramsFunc: paramsFunc
        });
        const pipeline = new capnp.Pipeline(Calculator_Evaluate$Results, answer);
        return new Calculator_Evaluate$Results$Promise(pipeline);
    }
    defFunction(paramsFunc?: (params: Calculator_DefFunction$Params) => void): Calculator_DefFunction$Results$Promise {
        const answer = this.client.call({
            method: Calculator$Client.methods[1],
            paramsFunc: paramsFunc
        });
        const pipeline = new capnp.Pipeline(Calculator_DefFunction$Results, answer);
        return new Calculator_DefFunction$Results$Promise(pipeline);
    }
    getOperator(paramsFunc?: (params: Calculator_GetOperator$Params) => void): Calculator_GetOperator$Results$Promise {
        const answer = this.client.call({
            method: Calculator$Client.methods[2],
            paramsFunc: paramsFunc
        });
        const pipeline = new capnp.Pipeline(Calculator_GetOperator$Results, answer);
        return new Calculator_GetOperator$Results$Promise(pipeline);
    }
}
capnp.Registry.register(Calculator$Client.interfaceId, Calculator$Client);
export interface Calculator$Server$Target {
    evaluate(params: Calculator_Evaluate$Params, results: Calculator_Evaluate$Results): Promise<void>;
    defFunction(params: Calculator_DefFunction$Params, results: Calculator_DefFunction$Results): Promise<void>;
    getOperator(params: Calculator_GetOperator$Params, results: Calculator_GetOperator$Results): Promise<void>;
}
export class Calculator$Server extends capnp.Server {
    readonly target: Calculator$Server$Target;
    constructor(target: Calculator$Server$Target) {
        super(target, [
            {
                ...Calculator$Client.methods[0],
                impl: target.evaluate
            },
            {
                ...Calculator$Client.methods[1],
                impl: target.defFunction
            },
            {
                ...Calculator$Client.methods[2],
                impl: target.getOperator
            }
        ]);
        this.target = target;
    }
    client(): Calculator$Client { return new Calculator$Client(this); }
}
export class Calculator extends __I {
    static readonly Expression = Calculator_Expression;
    static readonly Value = Calculator_Value;
    static readonly Function = Calculator_Function;
    static readonly Operator = Calculator_Operator;
    static readonly Client = Calculator$Client;
    static readonly Server = Calculator$Server;
    static readonly _capnp = { displayName: "Calculator", id: "97983392df35cc36", size: new __O(0, 0) };
    toString(): string { return "Calculator_" + super.toString(); }
}
Calculator_Expression_Call._Params = capnp.CompositeList(Calculator_Expression);
